# -*- coding: utf-8 -*-
"""SourceCodeGA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G4beseMCp1Sj2OpqkSyXz9c0HDbcGvky
"""

import random
from datetime import datetime

def generate_random_date():
    """Generates a random date in DD/MM/YYYY format."""
    day = random.randint(1, 31)
    month = random.randint(1, 12)
    year = random.randint(0, 9999)
    return f"{day:02d}/{month:02d}/{year:04d}"

def is_valid_date(date_str):
    """Checks if a given date string is valid."""
    try:
        day, month, year = map(int, date_str.split('/'))
        datetime(year, month, day)
        return True
    except ValueError:
        return False

def classify_date(date_str, target_categories):
    """Classifies the date based on predefined categories."""
    day, month, year = map(int, date_str.split('/'))
    for category, condition in target_categories.items():
        if condition(day, month, year):
            return category
    return "Unclassified"

def fitness_function(population, target_categories):
    """Evaluates the population based on test case diversity."""
    covered_categories = set()
    category_counts = {}  # To track redundant test cases
    fitness_scores = []

    for date in population:
        category = classify_date(date, target_categories)
        covered_categories.add(category)
        category_counts[category] = category_counts.get(category, 0) + 1

        # Reward based on uniqueness: Penalize redundant cases
        score = 10 if category != "Unclassified" else -5
        score -= 2 * (category_counts[category] - 1)  # Reduce score for redundant cases
        fitness_scores.append((date, score))

    coverage = (len(covered_categories) / len(target_categories)) * 100
    return fitness_scores, coverage

def crossover(parent1, parent2):
    """Generates a new test case by combining two parents."""
    d1, m1, y1 = parent1.split('/')
    d2, m2, y2 = parent2.split('/')

    child_options = [
        (d1, m2, y2),
        (d2, m1, y1),
        (d1, m1, y2),
        (d2, m2, y1)
    ]
    child = random.choice(child_options)
    return f"{child[0]}/{child[1]}/{child[2]}"

def mutate(date_str):
    """Mutates a test case by introducing variability."""
    day, month, year = map(int, date_str.split('/'))

    if random.random() < 0.2:  # Increase mutation probability
        day = random.randint(1, 31)  # Change day completely
    if random.random() < 0.2:
        month = random.randint(1, 12)  # Change month
    if random.random() < 0.2:
        year = random.randint(0, 9999)  # Change year

    # Introduce random swaps
    if random.random() < 0.1:
        day, month = month, day  # Swap day and month

    return f"{day:02d}/{month:02d}/{year:04d}"

def tournament_selection(population, fitness_scores, k=4):
    """Selects a diverse set of parents using tournament selection."""
    selected = []
    for _ in range(len(population) // 2):
        competitors = random.sample(fitness_scores, k)
        winner = max(competitors, key=lambda x: x[1])[0]  # Pick best of k
        selected.append(winner)
    return selected

def genetic_algorithm(target_categories, max_generations=100, coverage_goal=95):
    """Runs the genetic algorithm to generate diverse test cases."""
    population = [generate_random_date() for _ in range(5)]  # Random base
    valid_dates = [generate_random_date() for _ in range(20) if is_valid_date(generate_random_date())][:10]
    invalid_dates = [generate_random_date() for _ in range(20) if not is_valid_date(generate_random_date())][:10]

    population += valid_dates  # Ensure at least 10 valid test cases
    population += invalid_dates  # Ensure at least 10 invalid test cases
    population += ["01/01/0000", "31/12/9999", "29/02/2020", "30/02/2021", "31/04/2023"]  # Boundary cases
    generation = 0

    while generation < max_generations:
        fitness_scores, coverage = fitness_function(population, target_categories)
        if coverage >= coverage_goal:
            break

        # Select parents using tournament selection
        selected = tournament_selection(population, fitness_scores)

        # Generate next generation using crossover and mutation
        new_population = []
        while len(new_population) < 20:
            p1, p2 = random.sample(selected, 2)
            child = crossover(p1, p2)
            child = mutate(child)
            new_population.append(child)

        population = new_population
        generation += 1

    return population, coverage, generation

target_categories = {
    "Valid Leap Year": lambda d, m, y: m == 2 and d == 29 and ((y % 4 == 0 and y % 100 != 0) or (y % 400 == 0)),
    "Invalid Leap Year": lambda d, m, y: m == 2 and d == 29 and not ((y % 4 == 0 and y % 100 != 0) or (y % 400 == 0)),
    "Boundary Min Year": lambda d, m, y: y == 0 and d == 1 and m == 1,
    "Boundary Max Year": lambda d, m, y: y == 9999 and d == 31 and m == 12,
    "Invalid Month": lambda d, m, y: m > 12 or m < 1,
    "Invalid Day in February": lambda d, m, y: m == 2 and d > 29,
    "30th February": lambda d, m, y: m == 2 and d == 30,
    "31st April": lambda d, m, y: m == 4 and d == 31,
    "Negative Year": lambda d, m, y: y < 0,
}

best_population, final_coverage, generations = genetic_algorithm(target_categories)

valid_cases = [case for case in best_population if "Valid" in classify_date(case, target_categories)]
invalid_cases = [case for case in best_population if "Invalid" in classify_date(case, target_categories)]
boundary_cases = [case for case in best_population if "Boundary" in classify_date(case, target_categories)]

print("Best Test Cases:")
print("Valid:", valid_cases)
print("Invalid:", invalid_cases)
print("Boundary:", boundary_cases)
print("Coverage Achieved:", final_coverage, "%")
print("Generations Executed:", generations)